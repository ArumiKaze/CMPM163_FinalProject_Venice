<!DOCTYPE html>
<html lang="en">
	<head>
		<title>CMPM163 Venice Simulation</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
			  	margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/dat.gui.min.js"></script>

		<script src="js/skyshader.js"></script>

		<script src="js/cloudShader1.js"></script>
		<script>
			var container;
			var camera, controls, scene, renderer;
			var sky, sunSphere, moonSphere;
			var options;

			var cloud, cloudGeometry, cloudMaterial;
			
			Sky.prototype = Object.create( THREE.Mesh.prototype );

			init();
			animate();
			
			function init() {
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 100, 2000000 );
				camera.position.set( 0, 100, 2000 );
				scene = new THREE.Scene();

				/////////////////////Particle Clouds//////////////////////
				//large geometry which holds all the clouds
				cloudGeometry = new THREE.Geometry();

				var cloudTexture = new THREE.TextureLoader().load( "images/cloud.png");

				cloudMaterial = new THREE.ShaderMaterial( {
					uniforms: {
						texture: { type: "t", value: cloudTexture },
					},
					vertexShader : cloudVS,
					fragmentShader : cloudFS,
					depthWrite : false,
					depthTest : false,
					transparent : true
				} );

				//mesh per cloud (uses plane geometry)
				var cloudMeshIndividual = new THREE.Mesh( new THREE.PlaneGeometry( 80, 80 ) ); //changing the plane size will also change cloud size

				//modifiable values ~ these decide how the cloud object gets assembled
				var cloudSpreadWidth = 20000; //this number needs to be quite high in order for changes to be noticable (changes how thin or wide the object is)
				var cloudProximity = 10; //this determines how close the clouds are together
				var cloudDepth = 800; //this should be changed with cloudSpreadWidth in order to create more cloud layers (wider spread needs a higher depth number)
				var cloudSize = 10.5; //this is one factor in determining the size of the clouds ~ it should be changed alongsize the (x,y) of the "cloudMeshIndividual" plane
				var numClouds = 10000; //tells the loop how many clouds to make

				//this loop creates i amount clouds in the cloud object
				for ( var i = 0; i < numClouds; i++ ) {
					cloudMeshIndividual.position.x = Math.random() * cloudSpreadWidth;
					cloudMeshIndividual.position.y = i * cloudProximity - numClouds;
					cloudMeshIndividual.position.z = - Math.random() * Math.random() * cloudDepth;
					cloudMeshIndividual.rotation.z = Math.random() * Math.PI *2;
					cloudMeshIndividual.scale.x = cloudMeshIndividual.scale.y = Math.random() * cloudSize + 1.5;
					
					//each cloud "plane" is merged with the larger geometry ~ this improves performance
					cloudMeshIndividual.updateMatrix();
					cloudGeometry.merge(cloudMeshIndividual.geometry, cloudMeshIndividual.matrix);
				}

				//this is the merged cloud object
				cloud = new THREE.Mesh( cloudGeometry, cloudMaterial );
				cloud.rotation.x = Math.PI/2;
				cloud.position.y = 2 * numClouds;
				cloud.position.z = -10 * numClouds;
				scene.add( cloud );
				
				//////////////////End Particle Clouds///////////////////

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render );
				controls.enableZoom = false;
				controls.enablePan = false;
				initializesky();
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function Sky(){
				var uniforms = {
					luminance: { value: 1.1 },
					turbidity: { value: 2 },
					rayleigh: { value: 1 },
					mieCoefficient: { value: 0.005 },
					mieDirectionalG: { value: 0.8 },
					sunPosition: { value: new THREE.Vector3() },
					moonturbidity: { value: 1 },
					moonrayleigh: { value: 0 },
					moonmieCoefficient: { value: 0.001 },
					moonmieDirectionalG: { value: 0.984 },
					moonPosition: { value: new THREE.Vector3() }
				};
				var material = new THREE.ShaderMaterial( {
					fragmentShader: skyfs,
					vertexShader: skyvs,
					uniforms: THREE.UniformsUtils.clone( uniforms ),
					side: THREE.BackSide
				} );
				THREE.Mesh.call( this, new THREE.SphereBufferGeometry( 1, 40, 15 ), material );
			}
			function initializesky() {
				sky = new Sky();
				sky.scale.setScalar( 450000 );
				scene.add( sky );
				sunSphere = new THREE.Mesh(
					new THREE.SphereBufferGeometry( 20000, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff } )
				);
				sunSphere.position.y = - 700000;
				sunSphere.visible = false;
				scene.add( sunSphere );
				moonSphere = new THREE.Mesh(
					new THREE.SphereBufferGeometry( 20000, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff } )
				);
				moonSphere.position.y =  700000;
				moonSphere.visible = false;
				scene.add( moonSphere );
				options  = {
					Time: 1
				};
				var turbidity = 10;
				var rayleigh = 1.5;
				var mieCoefficient = 0.005;
				var mieDirectionalG = 0.8;
				var moonturbidity = 1;
				var moonrayleigh = 0;
				var moonmieCoefficient = 0.001;
				var moonmieDirectionalG = 0.984;
				var luminance = 1.05;
				var inclination = 0.49;
				var azimuth = 0.25;
				var sun = false;
				var moon = false;
				
				var distance = 400000;
				var inclination = 0.49;
				var uniforms = sky.material.uniforms;
				uniforms.turbidity.value = turbidity;
				uniforms.rayleigh.value = rayleigh;
				uniforms.luminance.value = luminance;
				uniforms.mieCoefficient.value = mieCoefficient;
				uniforms.mieDirectionalG.value = mieDirectionalG;
				uniforms.moonturbidity.value = moonturbidity;
				uniforms.moonrayleigh.value = moonrayleigh;
				uniforms.moonmieCoefficient.value = moonmieCoefficient;
				uniforms.moonmieDirectionalG.value = moonmieDirectionalG;
				var theta = Math.PI * ( inclination - 0.5 );
				var phi = 2 * Math.PI * ( azimuth - 0.5 );
				sunSphere.position.x = distance * Math.cos( phi );
				sunSphere.position.y = distance * Math.sin( phi ) * Math.sin( theta );
				sunSphere.position.z = distance * Math.sin( phi ) * Math.cos( theta );
				sunSphere.visible = sun;
				uniforms.sunPosition.value.copy( sunSphere.position );
				var theta = Math.PI * ( inclination + 0.5 );
				var phi = 2 * Math.PI * ( azimuth - 0.5 );
				moonSphere.position.x = distance * Math.cos( phi );
				moonSphere.position.y = distance * Math.sin( phi ) * Math.sin( theta );
				moonSphere.position.z = distance * Math.sin( phi ) * Math.cos( theta );
				moonSphere.visible = moon;
				uniforms.moonPosition.value.copy( moonSphere.position );
				var gui = new dat.GUI();
				gui.add( options, "Time", 0.5, 10);
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				render();
			}
			function render() {
				//cloud movement speed
				cloud.position.z += 0.5; //this should be quite low to ensure it takes a while before the cloud object goes offscreen

				var time = performance.now()/(options.Time*10000);
				var uniforms = sky.material.uniforms;
				var distance = 400000;
				var inclination = 0.49;
				var theta = Math.PI * ( inclination*time - 0.5 );
				var phi = 2 * Math.PI * ( 0.25 - 0.5 );
				sunSphere.position.y = distance * Math.sin( phi ) * Math.sin( theta );
				sunSphere.position.z = distance * Math.sin( phi ) * Math.cos( theta );
				uniforms.sunPosition.value.copy( sunSphere.position );
				var theta = Math.PI * ( inclination*time + 0.5 );
				var phi = 2 * Math.PI * ( 0.25 - 0.5 );
				moonSphere.position.y = distance * Math.sin( phi ) * Math.sin( theta );
				moonSphere.position.z = distance * Math.sin( phi ) * Math.cos( theta );
				uniforms.moonPosition.value.copy( moonSphere.position );
				renderer.render( scene, camera );
			}
		</script>

	</body>

</html>