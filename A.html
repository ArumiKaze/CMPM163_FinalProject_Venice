<!DOCTYPE html>
<html lang="en">
	<head>
		<title>CMPM163 Venice Simulation</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
			  	margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/dat.gui.min.js"></script>
		<script src="js/skyshader.js"></script>

		<script>
			var container;
			var camera, controls, scene, renderer;
			var sky, sunSphere, moonSphere;
			var options;
			
			Sky.prototype = Object.create( THREE.Mesh.prototype );
			init();
			animate();
			function init() {
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 100, 2000000 );
				camera.position.set( 0, 100, 2000 );
				scene = new THREE.Scene();
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render );
				controls.enableZoom = false;
				controls.enablePan = false;
				initializesky();
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function Sky(){
				var uniforms = {
					luminance: { value: 1.1 },
					turbidity: { value: 2 },
					rayleigh: { value: 1 },
					mieCoefficient: { value: 0.005 },
					mieDirectionalG: { value: 0.8 },
					sunPosition: { value: new THREE.Vector3() },
					moonturbidity: { value: 1 },
					moonrayleigh: { value: 0 },
					moonmieCoefficient: { value: 0.001 },
					moonmieDirectionalG: { value: 0.984 },
					moonPosition: { value: new THREE.Vector3() }
				};
				var material = new THREE.ShaderMaterial( {
					fragmentShader: skyfs,
					vertexShader: skyvs,
					uniforms: THREE.UniformsUtils.clone( uniforms ),
					side: THREE.BackSide
				} );
				THREE.Mesh.call( this, new THREE.SphereBufferGeometry( 1, 40, 15 ), material );
			}
			function initializesky() {
				sky = new Sky();
				sky.scale.setScalar( 450000 );
				scene.add( sky );
				sunSphere = new THREE.Mesh(
					new THREE.SphereBufferGeometry( 20000, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff } )
				);
				sunSphere.position.y = - 700000;
				sunSphere.visible = false;
				scene.add( sunSphere );
				moonSphere = new THREE.Mesh(
					new THREE.SphereBufferGeometry( 20000, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff } )
				);
				moonSphere.position.y =  700000;
				moonSphere.visible = false;
				scene.add( moonSphere );
				options  = {
					Time: 1
				};
				var turbidity = 10;
				var rayleigh = 1.5;
				var mieCoefficient = 0.005;
				var mieDirectionalG = 0.8;
				var moonturbidity = 1;
				var moonrayleigh = 0;
				var moonmieCoefficient = 0.001;
				var moonmieDirectionalG = 0.984;
				var luminance = 1.05;
				var inclination = 0.49;
				var azimuth = 0.25;
				var sun = false;
				var moon = false;
				
				var distance = 400000;
				var inclination = 0.49;
				var uniforms = sky.material.uniforms;
				uniforms.turbidity.value = turbidity;
				uniforms.rayleigh.value = rayleigh;
				uniforms.luminance.value = luminance;
				uniforms.mieCoefficient.value = mieCoefficient;
				uniforms.mieDirectionalG.value = mieDirectionalG;
				uniforms.moonturbidity.value = moonturbidity;
				uniforms.moonrayleigh.value = moonrayleigh;
				uniforms.moonmieCoefficient.value = moonmieCoefficient;
				uniforms.moonmieDirectionalG.value = moonmieDirectionalG;
				var theta = Math.PI * ( inclination - 0.5 );
				var phi = 2 * Math.PI * ( azimuth - 0.5 );
				sunSphere.position.x = distance * Math.cos( phi );
				sunSphere.position.y = distance * Math.sin( phi ) * Math.sin( theta );
				sunSphere.position.z = distance * Math.sin( phi ) * Math.cos( theta );
				sunSphere.visible = sun;
				uniforms.sunPosition.value.copy( sunSphere.position );
				var theta = Math.PI * ( inclination + 0.5 );
				var phi = 2 * Math.PI * ( azimuth - 0.5 );
				moonSphere.position.x = distance * Math.cos( phi );
				moonSphere.position.y = distance * Math.sin( phi ) * Math.sin( theta );
				moonSphere.position.z = distance * Math.sin( phi ) * Math.cos( theta );
				moonSphere.visible = moon;
				uniforms.moonPosition.value.copy( moonSphere.position );
				var gui = new dat.GUI();
				gui.add( options, "Time", 0.5, 10);
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				render();
			}
			function render() {
				var time = performance.now()/(options.Time*10000);
				var uniforms = sky.material.uniforms;
				var distance = 400000;
				var inclination = 0.49;
				var theta = Math.PI * ( inclination*time - 0.5 );
				var phi = 2 * Math.PI * ( 0.25 - 0.5 );
				sunSphere.position.y = distance * Math.sin( phi ) * Math.sin( theta );
				sunSphere.position.z = distance * Math.sin( phi ) * Math.cos( theta );
				uniforms.sunPosition.value.copy( sunSphere.position );
				var theta = Math.PI * ( inclination*time + 0.5 );
				var phi = 2 * Math.PI * ( 0.25 - 0.5 );
				moonSphere.position.y = distance * Math.sin( phi ) * Math.sin( theta );
				moonSphere.position.z = distance * Math.sin( phi ) * Math.cos( theta );
				uniforms.moonPosition.value.copy( moonSphere.position );
				renderer.render( scene, camera );
			}
		</script>

	</body>

</html>